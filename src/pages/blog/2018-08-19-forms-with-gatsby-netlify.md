---
templateKey: "blog-post"
title: "Forms with Gatsby & Netlify"
date: "2018-08-19T16:55:10.000Z"
description: >-
  Submission made easy
caption: What testing forms looks like...
canonical: ""
tags:
  - gatsby
  - netlify
  - forms
  - this-site
---

The last thing I am doing before advertising this site any wider than my Twitter circle is implementing a contact form, else this is but a kind of desecrated ivory tower from which I sit and declare my imperfections - I'd far rather have someone else cleverer outline my imperfections for me, so please do send me a message via the contact tab above. In the meanwhile, I'll explain how I implemented it.

## Dreams of Contact

I've integrated numerous forms, principally with databases via backend Express servers, but I've played around with serverless databases on AWS and Firebase too. So I wasn't too fussed about the prospect of setting up a server to collect submissions and holding them on a free tier somewhere - probably MLab or Firestore. But Scott Tolinsky on the [Syntax podcast](https://syntax.fm/), who incessantly raves about Netlify, mentioned that they 'handled forms'. A strangely specific service, I thought, but I decided to investigate, because, y'know, new stuff is cool.

Their [documentation](https://www.netlify.com/docs/form-handling/) is pretty clear, and it wasn't long before I realised they'd managed to secrete this magic away in just one prop you add to a form element. There are a couple of kinks in how to apply this - firstly because it's a React site (so forms are programmatically generated by JavaScript), but the second kink actually somewhat straightens out the first as it being a Gatsby site, it prerenders on the server first anyway. [This blog post](https://www.netlify.com/blog/2017/07/20/how-to-integrate-netlifys-form-handling-in-a-react-app/) was pretty invaluable in detailing what differences needed to be made, but I will outline how I approached it on this site anyway. You may encounter one annoyance in testing it - as you're relying on Netlify to parse the html to add the form functionality, you can't check it's working in dev mode. It took 2 1/2 minutes each time I made a change to deploy it and see if it was still working, which is not a rate of work I find conducive to sanity.

## The Method

Most of the magic happens in a contact.js file in the pages folder. As you can see on the imports, I'm using styled components (which I will blog about at some point). I've removed a few unrelated things too. Anyway, let's take a look at it:

```js
import React from "react";
import /* various */ "../../styled-components";
import { encode } from "../../utils/helpers";

export default class Contact extends React.Component {
  state = {
    name: "",
    email: "",
    message: "",
    hunny: "",
    formSent: false,
    formSendError: false,
    submitting: false
  };

  render() {
    const {
      formSent,
      formSendError,
      submitting,
      name,
      email,
      message,
      hunny
    } = this.state;
    return (
      <Main>
        <TransitionContainer>
          <SuperTitle>Contact</SuperTitle>
          <Paragraph>/* intro stuff... */</Paragraph>
          {formSendError && <Opener>Oops!</Opener>}
          {formSent && <Opener>Thanks!</Opener>}
          <form
            name="contact"
            method="post"
            data-netlify="true"
            onSubmit={this.handleSubmit}
          >
            <input type="hidden" name="form-name" value="contact" />
            <p hidden>
              <input name="hunny" onChange={this.handleChange} value={hunny} />
            </p>
            <FormLabel>Your name:</FormLabel>
            <FormInput
              type="text"
              name="name"
              onChange={this.handleChange}
              value={name}
            />
            /* Some more form inputs... */
            <FormButton
              type="submit"
              disabled={submitting || !name || !email || !message}
            >
              Send
            </FormButton>
          </form>
        </TransitionContainer>
      </Main>
    );
  }

  handleChange = e => {
    this.setState({
      [e.target.name]: e.target.value
    });
  };

  handleSubmit = e => {
    const { name, email, message, hunny } = this.state;

    if (hunny) return;

    this.setState({
      formSent: false,
      formSendError: false,
      submitting: true
    });

    const encoding = encode({
      "form-name": "contact",
      name,
      email,
      message
    });

    const headers = {
      "Content-Type": "application/x-www-form-urlencoded"
    };

    fetch("/", {
      method: "POST",
      headers,
      body: encoding
    })
      .then(() => {
        this.setState({
          formSent: true,
          name: "",
          email: "",
          message: "",
          submitting: false
        });
      })
      .catch(err => {
        this.setState({
          formSendError: err,
          submitting: false
        });
      });

    e.preventDefault();
  };
}
```

Let's have a look at some the things that make this function.

- The `<form>` element has most of the magic stuff in. The `data-netlify="true"` prop is what netlify uses to hook into the onSubmit and capture the data. Apparently just having `netlify` as a prop should work too, but it didn't for me. The `name` prop is what Netlify will store responses under in your admin panel.

- There's a very important hidden `input` field as the first child of the form. This is required because of the aforementioned programmatic generation of the form - exactly how Netlify uses this, I cannot say.

- Internally, Netlify will do some spam filtering, including using a Recaptcha if they smell a rat apparently. Something else you can do is add a 'honeypot' as you can see above. Netlify have this service built in - you can provide a hidden form input that only a bot would fill in, and see Netlify 'quietly discard' the submission. But with a stateful React component like I have here, I can prevent the submission even being made.

- Netlify expects submissions in x-www-form-urlencoded format - basically key=value pairs, joined with '&' - here's the little helper function I used to do this:

```js
const encode = data => {
  return Object.entries(data)
    .map(([key, value]) => {
      const encKey = encodeURIComponent(key);
      const encVal = encodeURIComponent(value);
      return `${encKey}=${encVal}`;
    })
    .join("&");
};
```

It requires a `form-name` property and all the fields that you wish to submit alongside.

You can integrate hooks too so you can trigger functions on receiving a form submission - I don't really want to have to log into Netlify to check on submissions, so I will work on latching it on to emails as soon as possible.

Any strong opinions? Well, you know how to let me know.
